<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SizeKit - Manual Calibration</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Camera Screen -->
    <div id="camera-screen">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay-canvas"></canvas>
    </div>

    <!-- Instructions Overlay -->
    <div id="instructions">
        <div id="instruction-text">Tap your credit card</div>
        <div id="instruction-detail">Place card flat on surface</div>
        <button id="reset-btn" style="display: none;">Reset</button>
    </div>

    <!-- Debug Console (bottom) -->
    <div id="debug-console">
        <div class="debug-line">Initializing...</div>
    </div>

    <!-- Load OpenCV.js from CDN -->
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <!-- Load modules -->
    <script src="modules/camera.js"></script>
    <script src="modules/cardDetector.js"></script>

    <!-- Main app logic -->
    <script>
        // Wait for OpenCV to load
        let openCvReady = false;
        
        function onOpenCvReady() {
            openCvReady = true;
            addDebug('✓ OpenCV.js loaded', 'success');
            console.log('OpenCV.js version:', cv.getBuildInformation());
        }

        // Credit card standard dimensions (ISO/IEC 7810 ID-1)
        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        // App state
        const STATE = {
            WAITING: 'waiting',
            DETECTING: 'detecting',
            LOCKED: 'locked'
        };

        let debugLines = [];
        const maxDebugLines = 6;
        let tapPoint = null;
        let pixelsPerMM = null;
        let cardDetector = null;
        let currentState = STATE.WAITING;
        let detectionAttempts = 0;
        const MAX_DETECTION_ATTEMPTS = 30; // Try for ~1 second after tap

        /**
         * Add debug message to console
         */
        function addDebug(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            debugLines.push({ time: timestamp, msg: message, type: type });
            
            if (debugLines.length > maxDebugLines) {
                debugLines.shift();
            }
            
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerHTML = debugLines.map(line => {
                const className = line.type === 'error' ? 'debug-error' : 
                                 line.type === 'success' ? 'debug-success' :
                                 line.type === 'warning' ? 'debug-warning' : '';
                return `<div class="debug-line ${className}">[${line.time}] ${line.msg}</div>`;
            }).join('');
        }

        /**
         * Update instruction text based on state
         */
        function updateInstructions() {
            const textEl = document.getElementById('instruction-text');
            const detailEl = document.getElementById('instruction-detail');
            const resetBtn = document.getElementById('reset-btn');

            // Remove all state classes
            textEl.className = '';
            detailEl.className = '';

            switch (currentState) {
                case STATE.WAITING:
                    textEl.textContent = 'Tap your credit card';
                    detailEl.textContent = 'Place card flat on surface';
                    resetBtn.style.display = 'none';
                    break;

                case STATE.DETECTING:
                    textEl.textContent = 'Detecting...';
                    textEl.className = 'warning';
                    detailEl.textContent = 'Hold steady';
                    resetBtn.style.display = 'block';
                    break;

                case STATE.LOCKED:
                    textEl.textContent = '✓ Card Detected!';
                    textEl.className = 'success';
                    detailEl.textContent = `Scale: ${pixelsPerMM ? pixelsPerMM.toFixed(2) + ' px/mm' : '...'}`;
                    detailEl.className = 'highlight';
                    resetBtn.style.display = 'block';
                    break;
            }
        }

        /**
         * Reset detection
         */
        function resetDetection() {
            tapPoint = null;
            pixelsPerMM = null;
            currentState = STATE.WAITING;
            detectionAttempts = 0;
            if (cardDetector) {
                cardDetector.lastDetection = null;
                cardDetector.smoothedCorners = null;
            }
            updateInstructions();
            addDebug('Reset - tap card to detect', 'warning');
        }

        /**
         * Get search region around tap point
         */
        function getSearchRegion(tapX, tapY, canvasWidth, canvasHeight) {
            // Create a large search area around the tap
            const searchSize = Math.min(canvasWidth, canvasHeight) * 0.8;
            
            return {
                x: Math.max(0, tapX - searchSize / 2),
                y: Math.max(0, tapY - searchSize / 2),
                width: Math.min(searchSize, canvasWidth),
                height: Math.min(searchSize, canvasHeight)
            };
        }

        /**
         * Handle tap/click on canvas
         */
        function handleTap(event) {
            // Only accept taps in WAITING state
            if (currentState !== STATE.WAITING) return;

            const canvas = document.getElementById('overlay-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // Get tap position in canvas coordinates
            let clientX, clientY;
            if (event.type === 'touchstart' || event.type === 'touchend') {
                clientX = event.touches[0]?.clientX || event.changedTouches[0]?.clientX;
                clientY = event.touches[0]?.clientY || event.changedTouches[0]?.clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Convert from screen coordinates to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            tapPoint = { x, y };
            currentState = STATE.DETECTING;
            detectionAttempts = 0;
            
            addDebug(`Tapped at (${x.toFixed(0)}, ${y.toFixed(0)}) - detecting card...`, 'info');
            updateInstructions();
        }

        /**
         * Calculate pixels per millimeter from detected corners
         */
        function calculateScale(corners) {
            if (!corners || corners.length !== 4) return;
            
            // Calculate average width (top edge + bottom edge)
            const topWidth = Math.sqrt(
                Math.pow(corners[1].x - corners[0].x, 2) + 
                Math.pow(corners[1].y - corners[0].y, 2)
            );
            const bottomWidth = Math.sqrt(
                Math.pow(corners[2].x - corners[3].x, 2) + 
                Math.pow(corners[2].y - corners[3].y, 2)
            );
            const avgWidthPx = (topWidth + bottomWidth) / 2;

            // Calculate average height (left edge + right edge)
            const leftHeight = Math.sqrt(
                Math.pow(corners[3].x - corners[0].x, 2) + 
                Math.pow(corners[3].y - corners[0].y, 2)
            );
            const rightHeight = Math.sqrt(
                Math.pow(corners[2].x - corners[1].x, 2) + 
                Math.pow(corners[2].y - corners[1].y, 2)
            );
            const avgHeightPx = (leftHeight + rightHeight) / 2;

            // Calculate scale from both dimensions (average them)
            const scaleFromWidth = avgWidthPx / CARD_WIDTH_MM;
            const scaleFromHeight = avgHeightPx / CARD_HEIGHT_MM;
            const newScale = (scaleFromWidth + scaleFromHeight) / 2;
            
            // Only update if scale changed significantly (avoid spam)
            if (!pixelsPerMM || Math.abs(newScale - pixelsPerMM) / pixelsPerMM > 0.05) {
                pixelsPerMM = newScale;
                addDebug(`✓ Scale: ${pixelsPerMM.toFixed(2)} px/mm`, 'success');
            }
        }

        /**
         * Draw overlay based on state
         */
        function drawOverlay(ctx) {
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw video frame
            const video = document.getElementById('video');
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw based on current state
            switch (currentState) {
                case STATE.WAITING:
                    // Just show camera
                    break;

                case STATE.DETECTING:
                    // Show tap point as yellow dot
                    if (tapPoint) {
                        ctx.beginPath();
                        ctx.arc(tapPoint.x, tapPoint.y, 12, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    // Show detected card if available
                    if (cardDetector.lastDetection) {
                        cardDetector.drawOverlay(ctx, cardDetector.lastDetection);
                    }
                    break;

                case STATE.LOCKED:
                    // Show detected card overlay
                    if (cardDetector.lastDetection) {
                        cardDetector.drawOverlay(ctx, cardDetector.lastDetection);
                    }
                    break;
            }
        }

        /**
         * Initialize and run app
         */
        async function init() {
            try {
                // Wait for OpenCV to load
                addDebug('Loading OpenCV.js...', 'info');
                while (!openCvReady) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                addDebug('Starting camera...', 'info');
                
                const camera = new Camera();
                cardDetector = new CardDetector();
                
                const video = document.getElementById('video');
                const canvas = document.getElementById('overlay-canvas');
                const ctx = canvas.getContext('2d', {
                    willReadFrequently: true
                });

                // Initialize camera
                await camera.initialize(video, canvas);
                addDebug('✓ Camera ready', 'success');
                addDebug('Tap 4 corners of credit card', 'info');

                // Enable canvas interactions
                canvas.style.pointerEvents = 'auto';

                // Listen for taps (touch and click)
                canvas.addEventListener('click', handleTap);
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleTap(e);
                });

                // Reset button
                document.getElementById('reset-btn').addEventListener('click', resetDetection);

                // Main processing loop
                const processFrame = () => {
                    // Handle detecting state
                    if (currentState === STATE.DETECTING && tapPoint) {
                        detectionAttempts++;
                        
                        // Get the search region around tap point
                        const searchRegion = getSearchRegion(tapPoint.x, tapPoint.y, canvas.width, canvas.height);
                        
                        // Get image data
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Try to detect card in that region
                        const detection = cardDetector.detectCard(imageData, searchRegion);
                        
                        if (detection && cardDetector.isStable() && detection.corners) {
                            // Check scale is reasonable
                            calculateScale(detection.corners);
                            
                            if (pixelsPerMM && pixelsPerMM > 2 && pixelsPerMM < 15) {
                                // SUCCESS - card detected!
                                currentState = STATE.LOCKED;
                                addDebug(`✓ Detected! Scale: ${pixelsPerMM.toFixed(2)} px/mm`, 'success');
                                updateInstructions();
                            }
                        }
                        
                        // Check if we've exceeded max attempts
                        if (detectionAttempts >= MAX_DETECTION_ATTEMPTS) {
                            currentState = STATE.WAITING;
                            tapPoint = null;
                            addDebug('❌ Detection timeout - tap again', 'error');
                            updateInstructions();
                        }
                    }
                    
                    // Handle locked state - keep tracking
                    if (currentState === STATE.LOCKED && tapPoint) {
                        const searchRegion = getSearchRegion(tapPoint.x, tapPoint.y, canvas.width, canvas.height);
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        const detection = cardDetector.detectCard(imageData, searchRegion);
                        
                        if (detection && detection.corners) {
                            // Update scale
                            calculateScale(detection.corners);
                            updateInstructions();
                        }
                    }
                    
                    // Draw overlay
                    drawOverlay(ctx);
                    
                    requestAnimationFrame(processFrame);
                };
                
                processFrame();

            } catch (error) {
                console.error('Initialization error:', error);
                addDebug(`ERROR: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
                    addDebug('Camera access denied', 'error');
                } else if (!window.isSecureContext) {
                    addDebug('Requires HTTPS', 'error');
                }
            }
        }

        // Start app when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
