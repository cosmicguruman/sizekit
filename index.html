<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SizeKit - Manual Calibration</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Camera Screen -->
    <div id="camera-screen">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay-canvas"></canvas>
    </div>

    <!-- Guide Rectangle (credit card outline) -->
    <div id="guide-rectangle">
        <div class="guide-corner top-left"></div>
        <div class="guide-corner top-right"></div>
        <div class="guide-corner bottom-left"></div>
        <div class="guide-corner bottom-right"></div>
    </div>

    <!-- Instructions Overlay -->
    <div id="instructions">
        <div id="instruction-text">Align card with guide</div>
        <div id="instruction-detail">Then tap the 4 corners</div>
        <button id="reset-btn" style="display: none;">Reset</button>
    </div>

    <!-- Debug Console (bottom) -->
    <div id="debug-console">
        <div class="debug-line">Initializing...</div>
    </div>

    <!-- Load modules -->
    <script src="modules/camera.js"></script>
    <script src="modules/cardDetector.js"></script>

    <!-- Main app logic -->
    <script>
        // Credit card standard dimensions (ISO/IEC 7810 ID-1)
        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        // App state
        const STATE = {
            ALIGNING: 'aligning',
            COLLECTING_TAPS: 'collecting_taps',
            VERIFYING: 'verifying',
            LOCKED: 'locked',
            FAILED: 'failed'
        };

        let debugLines = [];
        const maxDebugLines = 6;
        let tappedCorners = [];
        let pixelsPerMM = null;
        let cardDetector = null;
        let currentState = STATE.ALIGNING;
        let verificationFrames = 0;
        let verificationAttempts = 0;
        const VERIFICATION_FRAMES_NEEDED = 10; // Must be stable for 10 frames
        const MAX_VERIFICATION_ATTEMPTS = 60; // Try for ~2 seconds

        const cornerNames = ['TOP-LEFT', 'TOP-RIGHT', 'BOTTOM-RIGHT', 'BOTTOM-LEFT'];

        /**
         * Add debug message to console
         */
        function addDebug(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            debugLines.push({ time: timestamp, msg: message, type: type });
            
            if (debugLines.length > maxDebugLines) {
                debugLines.shift();
            }
            
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerHTML = debugLines.map(line => {
                const className = line.type === 'error' ? 'debug-error' : 
                                 line.type === 'success' ? 'debug-success' :
                                 line.type === 'warning' ? 'debug-warning' : '';
                return `<div class="debug-line ${className}">[${line.time}] ${line.msg}</div>`;
            }).join('');
        }

        /**
         * Update instruction text based on state
         */
        function updateInstructions() {
            const textEl = document.getElementById('instruction-text');
            const detailEl = document.getElementById('instruction-detail');
            const resetBtn = document.getElementById('reset-btn');
            const guideEl = document.getElementById('guide-rectangle');

            // Remove all state classes
            textEl.className = '';
            detailEl.className = '';
            guideEl.className = '';

            switch (currentState) {
                case STATE.ALIGNING:
                    textEl.textContent = 'Align card with guide';
                    detailEl.textContent = 'Then tap the 4 corners';
                    resetBtn.style.display = 'none';
                    break;

                case STATE.COLLECTING_TAPS:
                    textEl.textContent = `Tap corner ${tappedCorners.length + 1} of 4`;
                    detailEl.textContent = cornerNames[tappedCorners.length];
                    detailEl.className = 'highlight';
                    resetBtn.style.display = 'block';
                    break;

                case STATE.VERIFYING:
                    textEl.textContent = 'Verifying...';
                    textEl.className = 'warning';
                    detailEl.textContent = 'Hold card steady';
                    guideEl.className = 'verifying';
                    resetBtn.style.display = 'block';
                    break;

                case STATE.LOCKED:
                    textEl.textContent = '✓ Card Locked!';
                    textEl.className = 'success';
                    detailEl.textContent = `Scale: ${pixelsPerMM ? pixelsPerMM.toFixed(2) + ' px/mm' : '...'}`;
                    detailEl.className = 'highlight';
                    guideEl.className = 'locked';
                    resetBtn.style.display = 'block';
                    break;

                case STATE.FAILED:
                    textEl.textContent = '❌ Verification Failed';
                    textEl.className = 'warning';
                    detailEl.textContent = 'Tap Reset and try again';
                    resetBtn.style.display = 'block';
                    break;
            }
        }

        /**
         * Reset calibration
         */
        function resetDetection() {
            tappedCorners = [];
            pixelsPerMM = null;
            currentState = STATE.ALIGNING;
            verificationFrames = 0;
            verificationAttempts = 0;
            if (cardDetector) {
                cardDetector.lastDetection = null;
                cardDetector.smoothedCorners = null;
            }
            updateInstructions();
            addDebug('Reset - align card and tap corners', 'warning');
        }

        /**
         * Get bounding box from 4 corners
         */
        function getBoundingBox(corners) {
            const xs = corners.map(c => c.x);
            const ys = corners.map(c => c.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            
            // Add 10% padding to search region
            const padding = 0.1;
            const width = maxX - minX;
            const height = maxY - minY;
            
            return {
                x: Math.max(0, minX - width * padding),
                y: Math.max(0, minY - height * padding),
                width: width * (1 + 2 * padding),
                height: height * (1 + 2 * padding)
            };
        }

        /**
         * Handle tap/click on canvas
         */
        function handleTap(event) {
            // Only accept taps in ALIGNING or COLLECTING_TAPS states
            if (currentState !== STATE.ALIGNING && currentState !== STATE.COLLECTING_TAPS) return;
            if (tappedCorners.length >= 4) return;

            const canvas = document.getElementById('overlay-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // Get tap position in canvas coordinates
            let clientX, clientY;
            if (event.type === 'touchstart' || event.type === 'touchend') {
                clientX = event.touches[0]?.clientX || event.changedTouches[0]?.clientX;
                clientY = event.touches[0]?.clientY || event.changedTouches[0]?.clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Convert from screen coordinates to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            tappedCorners.push({ x, y });
            addDebug(`Corner ${tappedCorners.length}: (${x.toFixed(0)}, ${y.toFixed(0)})`, 'success');

            // Update state
            if (tappedCorners.length === 1) {
                currentState = STATE.COLLECTING_TAPS;
            } else if (tappedCorners.length === 4) {
                currentState = STATE.VERIFYING;
                verificationFrames = 0;
                verificationAttempts = 0;
                addDebug('Starting verification...', 'info');
            }

            updateInstructions();
        }

        /**
         * Calculate pixels per millimeter from detected corners
         */
        function calculateScale(corners) {
            if (!corners || corners.length !== 4) return;
            
            // Calculate average width (top edge + bottom edge)
            const topWidth = Math.sqrt(
                Math.pow(corners[1].x - corners[0].x, 2) + 
                Math.pow(corners[1].y - corners[0].y, 2)
            );
            const bottomWidth = Math.sqrt(
                Math.pow(corners[2].x - corners[3].x, 2) + 
                Math.pow(corners[2].y - corners[3].y, 2)
            );
            const avgWidthPx = (topWidth + bottomWidth) / 2;

            // Calculate average height (left edge + right edge)
            const leftHeight = Math.sqrt(
                Math.pow(corners[3].x - corners[0].x, 2) + 
                Math.pow(corners[3].y - corners[0].y, 2)
            );
            const rightHeight = Math.sqrt(
                Math.pow(corners[2].x - corners[1].x, 2) + 
                Math.pow(corners[2].y - corners[1].y, 2)
            );
            const avgHeightPx = (leftHeight + rightHeight) / 2;

            // Calculate scale from both dimensions (average them)
            const scaleFromWidth = avgWidthPx / CARD_WIDTH_MM;
            const scaleFromHeight = avgHeightPx / CARD_HEIGHT_MM;
            const newScale = (scaleFromWidth + scaleFromHeight) / 2;
            
            // Only update if scale changed significantly (avoid spam)
            if (!pixelsPerMM || Math.abs(newScale - pixelsPerMM) / pixelsPerMM > 0.05) {
                pixelsPerMM = newScale;
                addDebug(`✓ Scale: ${pixelsPerMM.toFixed(2)} px/mm`, 'success');
            }
        }

        /**
         * Draw overlay based on state
         */
        function drawOverlay(ctx) {
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw video frame
            const video = document.getElementById('video');
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw based on current state
            switch (currentState) {
                case STATE.ALIGNING:
                    // Just show camera, guide is visible via CSS
                    break;

                case STATE.COLLECTING_TAPS:
                    // Show tapped corners as yellow dots
                    tappedCorners.forEach((corner, index) => {
                        ctx.beginPath();
                        ctx.arc(corner.x, corner.y, 10, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // Draw number
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((index + 1).toString(), corner.x, corner.y);
                    });
                    break;

                case STATE.VERIFYING:
                    // Show small yellow dots for taps
                    tappedCorners.forEach((corner) => {
                        ctx.beginPath();
                        ctx.arc(corner.x, corner.y, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                        ctx.fill();
                    });
                    // Also show detected card if available
                    if (cardDetector.lastDetection) {
                        cardDetector.drawOverlay(ctx, cardDetector.lastDetection);
                    }
                    break;

                case STATE.LOCKED:
                    // Show detected card overlay
                    if (cardDetector.lastDetection) {
                        cardDetector.drawOverlay(ctx, cardDetector.lastDetection);
                    }
                    break;

                case STATE.FAILED:
                    // Show red X over tapped region
                    if (tappedCorners.length === 4) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(tappedCorners[0].x, tappedCorners[0].y);
                        for (let i = 1; i < 4; i++) {
                            ctx.lineTo(tappedCorners[i].x, tappedCorners[i].y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                    break;
            }
        }

        /**
         * Initialize and run app
         */
        async function init() {
            try {
                addDebug('Starting camera...', 'info');
                
                const camera = new Camera();
                cardDetector = new CardDetector();
                
                const video = document.getElementById('video');
                const canvas = document.getElementById('overlay-canvas');
                const ctx = canvas.getContext('2d', {
                    willReadFrequently: true
                });

                // Initialize camera
                await camera.initialize(video, canvas);
                addDebug('✓ Camera ready', 'success');
                addDebug('Tap 4 corners of credit card', 'info');

                // Enable canvas interactions
                canvas.style.pointerEvents = 'auto';

                // Listen for taps (touch and click)
                canvas.addEventListener('click', handleTap);
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleTap(e);
                });

                // Reset button
                document.getElementById('reset-btn').addEventListener('click', resetDetection);

                // Main processing loop
                const processFrame = () => {
                    // Handle verification state
                    if (currentState === STATE.VERIFYING) {
                        verificationAttempts++;
                        
                        // Get the region of interest from tapped corners
                        const searchRegion = getBoundingBox(tappedCorners);
                        
                        // Get image data
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Try to detect card in that region
                        const detection = cardDetector.detectCard(imageData, searchRegion);
                        
                        if (detection && cardDetector.isStable() && detection.corners) {
                            // Check scale is reasonable
                            calculateScale(detection.corners);
                            
                            if (pixelsPerMM && pixelsPerMM > 2 && pixelsPerMM < 15) {
                                // Scale looks good! Count as verification frame
                                verificationFrames++;
                                
                                if (verificationFrames >= VERIFICATION_FRAMES_NEEDED) {
                                    // SUCCESS - card verified!
                                    currentState = STATE.LOCKED;
                                    addDebug(`✓ Verified! Scale: ${pixelsPerMM.toFixed(2)} px/mm`, 'success');
                                    updateInstructions();
                                }
                            } else {
                                // Scale is off - reset verification
                                verificationFrames = 0;
                            }
                        } else {
                            // Detection failed - reset verification counter
                            verificationFrames = 0;
                        }
                        
                        // Check if we've exceeded max attempts
                        if (verificationAttempts >= MAX_VERIFICATION_ATTEMPTS) {
                            currentState = STATE.FAILED;
                            addDebug('❌ Verification timeout - try again', 'error');
                            updateInstructions();
                        }
                    }
                    
                    // Handle locked state - keep tracking
                    if (currentState === STATE.LOCKED) {
                        const searchRegion = getBoundingBox(tappedCorners);
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        const detection = cardDetector.detectCard(imageData, searchRegion);
                        
                        if (detection && detection.corners) {
                            // Update scale
                            calculateScale(detection.corners);
                            updateInstructions();
                        }
                    }
                    
                    // Draw overlay
                    drawOverlay(ctx);
                    
                    requestAnimationFrame(processFrame);
                };
                
                processFrame();

            } catch (error) {
                console.error('Initialization error:', error);
                addDebug(`ERROR: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
                    addDebug('Camera access denied', 'error');
                } else if (!window.isSecureContext) {
                    addDebug('Requires HTTPS', 'error');
                }
            }
        }

        // Start app when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
