<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nail Measurement Test - Research Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
        }
        
        /* Camera View */
        #camera-screen {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #video {
            flex: 1;
            width: 100%;
            object-fit: cover;
        }
        
        #capture-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #fff;
            border: 5px solid #000;
            box-shadow: 0 0 0 3px #fff;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        #capture-btn:active {
            transform: translateX(-50%) scale(0.95);
        }
        
        #camera-instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        /* Results View */
        #results-screen {
            display: none;
            width: 100vw;
            min-height: 100vh;
            padding: 20px;
            background: #1a1a1a;
        }
        
        #captured-canvas {
            width: 100%;
            max-height: 50vh;
            object-fit: contain;
            border: 2px solid #333;
            border-radius: 10px;
            margin-bottom: 20px;
            cursor: crosshair;
        }
        
        .measurements-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .hand-section {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
        }
        
        .hand-section h3 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .finger-measurement {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: #333;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .finger-name {
            font-weight: 500;
        }
        
        .measurement-value {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }
        
        .mm-value {
            color: #4CAF50;
            font-weight: bold;
            font-size: 16px;
        }
        
        .size-value {
            color: #999;
            font-size: 12px;
        }
        
        .editable {
            border: 2px solid #ff9800;
            cursor: pointer;
        }
        
        .scale-info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .scale-info h3 {
            color: #2196F3;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .scale-detail {
            font-size: 14px;
            color: #ccc;
            margin: 5px 0;
        }
        
        .scale-warning {
            color: #ff9800;
            font-weight: bold;
        }
        
        .scale-good {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-secondary {
            background: #666;
            color: white;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            padding: 20px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top-color: #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #skip-ai-btn {
            margin-top: 30px;
            padding: 15px 30px;
            background: #ff9800;
            color: #000;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .manual-mode-banner {
            background: #ff9800;
            color: #000;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Initializing AI models...</div>
        <button id="skip-ai-btn">‚ö° Skip AI - Use Manual Mode</button>
        <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
            AI loading slow? Skip and measure manually<br>
            (You can click nails to measure)
        </div>
    </div>

    <!-- Camera Screen -->
    <div id="camera-screen" class="hidden">
        <video id="video" autoplay playsinline></video>
        <div id="camera-instructions">
            <strong>üì∏ Position for capture:</strong><br>
            1. Place credit card in frame<br>
            2. Spread all fingers wide<br>
            3. Ensure good lighting<br>
            4. Keep hand flat and steady
        </div>
        <button id="capture-btn"></button>
    </div>

    <!-- Results Screen -->
    <div id="results-screen">
        <h2 style="margin-bottom: 15px;">Measurement Results</h2>
        
        <canvas id="captured-canvas"></canvas>
        
        <div id="manual-mode-banner" class="manual-mode-banner hidden">
            üìù Manual Mode: Click on image to mark nail boundaries
        </div>
        
        <div class="scale-info" id="scale-info">
            <h3>üìè Scale Calibration</h3>
            <div class="scale-detail" id="scale-details">Analyzing...</div>
        </div>
        
        <div class="measurements-grid">
            <div class="hand-section">
                <h3>üñêÔ∏è Left Hand</h3>
                <div id="left-measurements"></div>
            </div>
            <div class="hand-section">
                <h3>üñêÔ∏è Right Hand</h3>
                <div id="right-measurements"></div>
            </div>
        </div>
        
        <div class="button-group">
            <button class="btn-secondary" id="retake-btn">üîÑ Retake Photo</button>
            <button class="btn-primary" id="manual-adjust-btn">‚úèÔ∏è Manual Adjust</button>
        </div>
    </div>

    <!-- TensorFlow.js and HandPose -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <script src="detection.js"></script>

    <script>
        // UI Elements
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const skipAiBtn = document.getElementById('skip-ai-btn');
        const cameraScreen = document.getElementById('camera-screen');
        const resultsScreen = document.getElementById('results-screen');
        const video = document.getElementById('video');
        const captureBtn = document.getElementById('capture-btn');
        const retakeBtn = document.getElementById('retake-btn');
        const manualAdjustBtn = document.getElementById('manual-adjust-btn');
        const capturedCanvas = document.getElementById('captured-canvas');
        const scaleInfo = document.getElementById('scale-info');
        const scaleDetails = document.getElementById('scale-details');
        const leftMeasurements = document.getElementById('left-measurements');
        const rightMeasurements = document.getElementById('right-measurements');
        const manualModeBanner = document.getElementById('manual-mode-banner');

        // State
        let handposeModel = null;
        let currentImageData = null;
        let currentReference = null;
        let currentMeasurements = null;
        let manualMode = false;
        let stream = null;
        let manualOnlyMode = false; // Skip AI entirely

        // Size conversion table (mm to size)
        const SIZE_TABLE = [
            { size: 0, min: 13.5, max: 100 },
            { size: 1, min: 13.0, max: 13.5 },
            { size: 2, min: 12.5, max: 13.0 },
            { size: 3, min: 12.0, max: 12.5 },
            { size: 4, min: 11.5, max: 12.0 },
            { size: 5, min: 11.0, max: 11.5 },
            { size: 6, min: 10.5, max: 11.0 },
            { size: 7, min: 10.0, max: 10.5 },
            { size: 8, min: 9.5, max: 10.0 },
            { size: 9, min: 0, max: 9.5 }
        ];

        function mmToSize(mm) {
            for (let entry of SIZE_TABLE) {
                if (mm >= entry.min && mm < entry.max) {
                    return entry.size;
                }
            }
            return 0;
        }

        // Skip AI button
        skipAiBtn.addEventListener('click', async () => {
            manualOnlyMode = true;
            loadingText.textContent = 'Starting in manual mode...';
            
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                video.srcObject = stream;
                
                loading.classList.add('hidden');
                cameraScreen.classList.remove('hidden');
                manualModeBanner.classList.remove('hidden');
                manualMode = true;
            } catch (error) {
                loadingText.textContent = `‚ùå Camera error: ${error.message}`;
            }
        });

        // Initialize
        async function init() {
            try {
                // Wait a moment for scripts to fully load
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                loadingText.textContent = 'Step 1/3: Checking TensorFlow.js...';
                console.log('TensorFlow available:', typeof tf !== 'undefined');
                
                if (typeof tf === 'undefined') {
                    throw new Error('TensorFlow.js failed to load. Reload the page.');
                }
                
                loadingText.textContent = 'Step 2/3: Requesting camera access...';
                console.log('Requesting camera...');
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                video.srcObject = stream;
                console.log('Camera stream acquired');

                loadingText.textContent = 'Step 3/3: Loading AI models (30-60 seconds, please wait)...';
                console.log('Loading handpose model...');
                
                const startTime = Date.now();
                handposeModel = await handpose.load();
                const loadTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                console.log(`‚úÖ Handpose model loaded in ${loadTime} seconds`);

                loading.classList.add('hidden');
                cameraScreen.classList.remove('hidden');
            } catch (error) {
                loadingText.innerHTML = `‚ùå Error: ${error.message}<br><br>Click "Skip AI" above to use manual mode.`;
                console.error('Init error:', error);
            }
        }

        // Capture photo
        captureBtn.addEventListener('click', async () => {
            captureBtn.disabled = true;
            captureBtn.style.opacity = '0.5';

            // Capture frame
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            // Store image data
            currentImageData = canvas.toDataURL('image/jpeg', 0.95);

            // Analyze
            await analyzePhoto(canvas, ctx);

            // Stop camera
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            // Show results
            cameraScreen.classList.add('hidden');
            resultsScreen.style.display = 'block';

            captureBtn.disabled = false;
            captureBtn.style.opacity = '1';
        });

        // Analyze photo
        async function analyzePhoto(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Detect credit card
            currentReference = await SizeKitDetection.detectReferenceObject({
                dataUrl: currentImageData
            });

            if (currentReference) {
                const scale = currentReference.pixelsPerMm;
                const isGood = scale >= 3 && scale <= 15;
                scaleDetails.innerHTML = `
                    <div>Card detected: ${currentReference.boundingBox.width}px √ó ${currentReference.boundingBox.height}px</div>
                    <div class="${isGood ? 'scale-good' : 'scale-warning'}">
                        Scale: ${scale.toFixed(3)} pixels/mm ${isGood ? '‚úì' : '‚ö†Ô∏è'}
                    </div>
                `;
            } else {
                scaleDetails.innerHTML = '<div class="scale-warning">‚ö†Ô∏è Credit card not detected! Measurements may be inaccurate.</div>';
            }

            // Draw on canvas and show
            const displayCanvas = capturedCanvas;
            displayCanvas.width = canvas.width;
            displayCanvas.height = canvas.height;
            const displayCtx = displayCanvas.getContext('2d');
            displayCtx.drawImage(canvas, 0, 0);

            // Draw credit card box
            if (currentReference) {
                const box = currentReference.boundingBox;
                displayCtx.strokeStyle = '#4CAF50';
                displayCtx.lineWidth = 4;
                displayCtx.strokeRect(box.x, box.y, box.width, box.height);
                displayCtx.fillStyle = '#4CAF50';
                displayCtx.font = 'bold 20px Arial';
                displayCtx.fillText('CARD', box.x + 10, box.y + 30);
            }

            // Process each hand
            currentMeasurements = { left: [], right: [] };
            
            // If manual-only mode, skip hand detection
            if (manualOnlyMode) {
                leftMeasurements.innerHTML = '<div style="color: #ff9800; padding: 10px;">Manual mode - Click nails on image to measure</div>';
                rightMeasurements.innerHTML = '<div style="color: #ff9800; padding: 10px;">Manual mode - Click nails on image to measure</div>';
                return;
            }

            // Detect hands with AI
            const predictions = await handposeModel.estimateHands(canvas);
            
            if (predictions.length === 0) {
                leftMeasurements.innerHTML = '<div style="color: #f44336; padding: 10px;">No hands detected - Use manual mode</div>';
                rightMeasurements.innerHTML = '<div style="color: #f44336; padding: 10px;">No hands detected - Use manual mode</div>';
                return;
            }

            predictions.forEach((hand, handIndex) => {
                const landmarks = hand.landmarks;
                const isLeft = handIndex === 0; // Assume first hand is left
                
                // Draw hand landmarks
                displayCtx.fillStyle = '#2196F3';
                landmarks.forEach(point => {
                    displayCtx.beginPath();
                    displayCtx.arc(point[0], point[1], 5, 0, 2 * Math.PI);
                    displayCtx.fill();
                });

                // Measure each finger
                const fingerNames = ['Thumb', 'Index', 'Middle', 'Ring', 'Pinky'];
                const fingerIndices = [4, 8, 12, 16, 20];

                fingerIndices.forEach((tipIndex, i) => {
                    const tip = landmarks[tipIndex];
                    const secondJoint = landmarks[tipIndex - 2];
                    
                    // Calculate nail width
                    const dx = tip[0] - secondJoint[0];
                    const dy = tip[1] - secondJoint[1];
                    const fingerLength = Math.sqrt(dx * dx + dy * dy);
                    const widthPx = fingerLength * 0.45; // Estimate
                    
                    // Convert to mm
                    const widthMm = currentReference ? 
                        widthPx / currentReference.pixelsPerMm : 
                        widthPx / 5; // Fallback estimate
                    
                    const sizeNumber = mmToSize(widthMm);

                    // Draw nail boundary estimate
                    displayCtx.strokeStyle = '#ff9800';
                    displayCtx.lineWidth = 3;
                    displayCtx.beginPath();
                    displayCtx.arc(tip[0], tip[1], widthPx / 2, 0, 2 * Math.PI);
                    displayCtx.stroke();

                    // Store measurement
                    const measurement = {
                        finger: fingerNames[i],
                        widthMm: widthMm,
                        sizeNumber: sizeNumber,
                        tip: tip,
                        widthPx: widthPx
                    };

                    if (isLeft) {
                        currentMeasurements.left.push(measurement);
                    } else {
                        currentMeasurements.right.push(measurement);
                    }
                });
            });

            // Display measurements
            displayMeasurements();
        }

        function displayMeasurements() {
            leftMeasurements.innerHTML = currentMeasurements.left.map(m => `
                <div class="finger-measurement">
                    <span class="finger-name">${m.finger}</span>
                    <div class="measurement-value">
                        <span class="mm-value">${m.widthMm.toFixed(1)}mm</span>
                        <span class="size-value">Size ${m.sizeNumber}</span>
                    </div>
                </div>
            `).join('');

            rightMeasurements.innerHTML = currentMeasurements.right.map(m => `
                <div class="finger-measurement">
                    <span class="finger-name">${m.finger}</span>
                    <div class="measurement-value">
                        <span class="mm-value">${m.widthMm.toFixed(1)}mm</span>
                        <span class="size-value">Size ${m.sizeNumber}</span>
                    </div>
                </div>
            `).join('');
        }

        // Retake photo
        retakeBtn.addEventListener('click', async () => {
            resultsScreen.style.display = 'none';
            manualMode = false;
            manualModeBanner.classList.add('hidden');
            
            if (manualOnlyMode) {
                // In manual mode, just restart camera
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                video.srcObject = stream;
                cameraScreen.classList.remove('hidden');
                manualMode = true;
                manualModeBanner.classList.remove('hidden');
            } else {
                // In AI mode, restart normally
                await init();
            }
        });

        // Manual adjustment mode
        manualAdjustBtn.addEventListener('click', () => {
            manualMode = !manualMode;
            manualModeBanner.classList.toggle('hidden');
            manualAdjustBtn.textContent = manualMode ? '‚úì Done Adjusting' : '‚úèÔ∏è Manual Adjust';
            
            if (manualMode) {
                alert('Click on the image to manually mark nail boundaries.\n\n1. Click left edge of nail\n2. Click right edge of nail\n\nMeasurement will update automatically.');
            }
        });

        // Manual canvas clicking (simplified for MVP)
        let manualClicks = [];
        capturedCanvas.addEventListener('click', (e) => {
            if (!manualMode) return;

            const rect = capturedCanvas.getBoundingClientRect();
            const scaleX = capturedCanvas.width / rect.width;
            const scaleY = capturedCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            manualClicks.push({ x, y });

            // Draw click point
            const ctx = capturedCanvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // If we have 2 clicks, calculate width
            if (manualClicks.length === 2) {
                const dx = manualClicks[1].x - manualClicks[0].x;
                const dy = manualClicks[1].y - manualClicks[0].y;
                const widthPx = Math.sqrt(dx * dx + dy * dy);
                const widthMm = currentReference ? 
                    widthPx / currentReference.pixelsPerMm : 
                    widthPx / 5;
                
                alert(`Manual measurement:\n${widthPx.toFixed(1)}px = ${widthMm.toFixed(1)}mm\nSize ${mmToSize(widthMm)}`);
                
                manualClicks = [];
            }
        });

        // Start - wait for all scripts to load
        if (document.readyState === 'complete') {
            setTimeout(init, 500);
        } else {
            window.addEventListener('load', () => {
                setTimeout(init, 500);
            });
        }
    </script>
</body>
</html>
